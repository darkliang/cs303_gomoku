Index: code_template.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- code_template.py	(date 1569499404708)
+++ code_template.py	(date 1569499404708)
@@ -5,55 +5,53 @@
 
 
 import numpy as np
-import random
 import time
 
 COLOR_BLACK = -1
 COLOR_WHITE = 1
 COLOR_NONE = 0
-random.seed(0)
 SCORE_MAX = 0x7fffffff
 SCORE_MIN = -1 * SCORE_MAX
 # 棋型的评估分数
-shape_score_5 = [(50, (0, 1, 1, 0, 0)),
-               (50, (0, 0, 1, 1, 0)),
-               (200, (1, 1, 0, 1, 0)),
-               (500, (0, 0, 1, 1, 1)),
-               (500, (1, 1, 1, 0, 0)),
-               (5000, (0, 1, 1, 1, 0)),
-               (5000, (0, 1, 0, 1, 1, 0)),
-               (5000, (0, 1, 1, 0, 1, 0)),
-               (5000, (1, 1, 1, 0, 1)),
-               (5000, (1, 1, 0, 1, 1)),
-               (5000, (1, 0, 1, 1, 1)),
-               (5000, (1, 1, 1, 1, 0)),
-               (5000, (0, 1, 1, 1, 1))]
-# shape_score_5 = [((230, 200), (0, 1, 0, 1, 0)),
-#                  ((300, 240), (0, 1, 1, 0, 0)),
-#                  ((300, 240), (0, 0, 1, 1, 0)),
-#                  ((500, 800), (1, 1, 0, 1, 0)),
-#                  ((500, 800), (0, 1, 0, 1, 1)),
-#                  ((600, 1000), (0, 0, 1, 1, 1)),
-#                  ((600, 1000), (1, 1, 1, 0, 0)),
-#                  ((1800, 2000), (0, 1, 1, 1, 0)),
-#                  ((2100, 2700), (1, 1, 1, 0, 1)),
-#                  ((2000, 2700), (1, 1, 0, 1, 1)),
-#                  ((2000, 2700), (1, 0, 1, 1, 1)),
-#                  ((2300, 3200), (1, 1, 1, 1, 0)),
-#                  ((2300, 3200), (0, 1, 1, 1, 1)),
-#                  ((100000, 100000), (1, 1, 1, 1, 1))]
-shape_score_6 = [
-    (50000, (0, 1, 1, 1, 1, 0)),
+shape_score_5 = [
+    (100, (1, 0, 1, 0, 0)),
+    (100, (0, 0, 1, 0, 1)),
+    (200, (1, 1, 0, 0, 0)),
+    (200, (0, 0, 0, 1, 1)),
+    (300, (0, 1, 0, 1, 0)),
+    (500, (0, 1, 1, 0, 0)),
+    (500, (0, 0, 1, 1, 0)),
+    (1000, (1, 1, 0, 1, 0)),
+    (1000, (0, 1, 0, 1, 1)),
+    (1000, (1, 0, 1, 1, 0)),
+    (1000, (0, 1, 1, 0, 1)),
+    (1500, (0, 0, 1, 1, 1)),
+    (1500, (1, 1, 1, 0, 0)),
+    (4000, (0, 1, 1, 1, 0)),
+    (6000, (1, 1, 1, 0, 1)),
+    (6000, (1, 1, 0, 1, 1)),
+    (6000, (1, 0, 1, 1, 1)),
+    (8000, (1, 1, 1, 1, 0)),
+    (8000, (0, 1, 1, 1, 1)),
     (99999999, (1, 1, 1, 1, 1))]
-next_point = [0, 0]
+
+shape_score_6 = [
+    (3500, (0, 1, 0, 1, 1, 0)),
+    (3500, (0, 1, 1, 0, 1, 0)),
+    (7000, (0, 1, 1, 1, 0, 1)),
+    (7000, (1, 0, 1, 1, 1, 0)),
+    (50000, (0, 1, 1, 1, 1, 0))
+]
 
 score_table = {
-    'five': 100000,
-    'live_four': 50000,
+    'five': 1000000,
+    'live_four': 80000,
     'jump_four': 20000,
-    'dead_four': 12000,
-    'live_three': 12000,
+    'jump_four_2': 15000,
+    'dead_four': 15000,
+    'live_three': 15000,
     'jump_three': 7000,
+    'jump_three_2': 5000,
     'dead_three': 5000,
     'live_two': 1000,
     'jump_two': 700,
@@ -73,12 +71,11 @@
         #   System will get the end of your candidate_list as your decision .
         self.candidate_list = []
         #   last my list
-        self.my_list = []
-        self.enemy_list = []
+
         self.empty_list = []
-        self.max_depth = 3
-        self.search_breadth = 5
-        self.bestmove = ()
+        self.max_depth = 4
+        self.search_breadth = 10
+        self.times = 0
 
     #   The input is current chessboard.
 
@@ -96,14 +93,16 @@
 
         start = time.time()
         self.alpha_beta(self.max_depth, chessboard, SCORE_MIN, SCORE_MAX, self.color)
+        # moves = []
+        # for point in self.empty_list:
+        #     if not self.has_neighbor(point, chessboard):
+        #         continue
+        #     chessboard[point[0]][point[1]] = self.color
+        #     score = self.evaluation(chessboard, self.color)
+        #     chessboard[point[0]][point[1]] = COLOR_NONE
+        #     moves.append((score, point))
+        # self.candidate_list.append(max(moves)[1])
         print(time.time() - start)
-        #   ==============Find new pos========================================
-        #   Make sure that the position of your decision in chess board is empty.
-        #   If not, return error.
-        #   assert chessboard[new_pos[0], new_pos[1]] == COLOR_NONE
-        #   Add your decision into candidate_list, Records the chess board
-        # self.candidate_list.append(next_point)
-        # self.candidate_list.append(next_moves[0][1])
 
     def has_neighbor(self, next_step, chessboard):
         x, y = next_step[0], next_step[1]
@@ -114,32 +113,65 @@
                         != COLOR_NONE:
                     return True
         return False
+
+    def is_win(self, chessboard, move, color):
+        direction = [(0, 1), (1, 0), (1, 1), (-1, 1)]
+        for x_d, y_d in direction:
+            line = [0 for _ in range(9)]
+            for i in range(-4, 5):
+                m = move[0] + i * x_d
+                n = move[1] + i * y_d
+                if (m < 0 or m >= self.chessboard_size or
+                        n < 0 or n >= self.chessboard_size):
+                    line[i + 4] = -color
+                else:
+                    line[i + 4] = chessboard[m][n]
+            color_number = 1
+            for i in range(3, -1, -1):
+                if line[i] == color:
+                    color_number += 1
+                else:
+                    break
+
+            for i in range(5, 9):
+                if line[i] == color:
+                    color_number += 1
+                else:
+                    break
+            if color_number >= 5:
+                return True
+
+        return False
 
     def alpha_beta(self, depth, chessboard, alpha, beta, color):
         if depth == 0 or len(self.empty_list) == 0:
             return self.evaluation(chessboard, color)
 
+        self.search_breadth = self.search_breadth - (4-depth) * 2
         moves = self.heuristic(chessboard, color)
-        bestmove = None
+        self.search_breadth = 10
         # if there are no moves, just return the score
 
         for _, (x, y) in moves:
             chessboard[x][y] = color
             self.empty_list.remove((x, y))
-            score = - self.alpha_beta(depth - 1, chessboard, -beta, -alpha, -color)
+
+            if self.is_win(chessboard, (x, y), color):
+                score = - self.evaluation(chessboard, -color)
+            else:
+                score = - self.alpha_beta(depth - 1, chessboard, -beta, -alpha, -color)
             self.empty_list.append((x, y))
 
             chessboard[x][y] = 0
 
             # alpha/beta pruning
             if score > alpha:
+                if depth == self.max_depth:
+                    self.candidate_list.append((x, y))
+                if score >= beta:
+                    self.times += 1
+                    return beta
                 alpha = score
-                bestmove = (x, y)
-                if alpha >= beta:
-                    break
-
-        if depth == self.max_depth and bestmove:
-            self.candidate_list.append(bestmove)
 
         return alpha
 
@@ -155,7 +187,7 @@
                 my_score += self.cal(chessboard, move[0], move[1], direction[i], color)
                 enemy_score += self.cal(chessboard, move[0], move[1], direction[i], -color)
 
-            moves.append((my_score + 0.75 * enemy_score, move))
+            moves.append((my_score + 0.7 * enemy_score, move))
         moves.sort(reverse=True)
         return moves[:self.search_breadth]
 
@@ -175,54 +207,57 @@
         left_gap, right_gap = 0, 0
         gap = 0
         for i in range(3, -1, -1):
-            if left_gap > 1:
-                break
-            elif line[i] == color:
+            if line[i] == color:
                 color_number += 1
                 if line[i + 1] == 0:
                     gap += 1
             elif line[i] == 0:
-                if i > 0:
-                    left_gap += 1
-                else:
+                if line[i + 1] == 0:
                     break
             else:
                 block += 1
+                if line[i + 1] == 0:
+                    left_gap += 1
                 break
 
         for i in range(5, 9):
-            if right_gap > 1:
-                break
-            elif line[i] == color:
+            if line[i] == color:
                 color_number += 1
                 if line[i - 1] == 0:
                     gap += 1
             elif line[i] == 0:  # 最后一个子不算gap
-                if i < 8:
-                    right_gap += 1
-                else:
+                if line[i - 1] == 0:
                     break
             else:
                 block += 1
+                if line[i - 1] == 0:
+                    right_gap += 1
                 break
 
-        if color_number == 5:
-            return score_table['five']
-        if block == 0 or (block == 1 and left_gap + right_gap + color_number >= 5):
+        if color_number >= 5:
+            if gap == 0:
+                return score_table['five']
+            else:
+                return score_table['live_four']
+        if block == 0 or (left_gap + right_gap + color_number + gap >= 5):
             if color_number == 4:  # 活四
-                if gap > 0:
+                if gap == 2:
+                    return score_table['jump_four_2']
+                elif gap == 1:
                     return score_table['jump_four']
                 else:
                     return score_table['live_four']
             elif color_number == 3:
-                if gap > 0:
+                if gap == 2:
+                    return score_table['jump_three_2']
+                elif gap == 1:
                     return score_table['jump_three']
                 else:
                     return score_table['live_three']
             elif color_number == 2:
-                if gap > 0:
+                if gap == 1:
                     return score_table['jump_two']
-                else:
+                elif gap == 0:
                     return score_table['live_two']
         elif block == 1:
             if color_number == 4:  # 死四
@@ -234,21 +269,6 @@
 
         return 0
 
-    def evaluate(self, chessboard, color):
-        my_score = 0
-        enemy_score = 0
-        direction = [(0, 1), (1, 0), (1, 1), (-1, 1)]
-        for x in range(0, self.chessboard_size):
-            for y in range(0, self.chessboard_size):
-                if chessboard[x][y] == color:
-                    for i in range(4):
-                        my_score += self.cal(chessboard, x, y, direction[i], color)
-                elif chessboard[x][y] == -color:
-                    for i in range(4):
-                        enemy_score += self.cal(chessboard, x, y, direction[i], color)
-
-        return my_score - enemy_score
-
     def evaluation(self, chessboard, color):
         # 算自己的得分
         score_all_arr = []  # 得分形状的位置 用于计算如果有相交 得分翻倍
@@ -266,51 +286,57 @@
                 elif chessboard[x][y] == -color:
                     for i in range(4):
                         enemy_score += self.cal_score(chessboard, x, y, direction[i][0], direction[i][1],
-                                                      score_all_arr_enemy, color)
+                                                      score_all_arr_enemy, -color)
 
-        total_score = my_score - 10 * enemy_score
+        total_score = my_score - 1 * enemy_score
         return total_score
 
-    def cal_score(self, chessboard, m, n, x_direction, y_direction, score_all_arr, color,):
+    def cal_score(self, chessboard, m, n, x_direction, y_direction, score_all_arr, color, ):
 
         # 在一个方向上， 只取最大的得分项
         max_score_shape = (0, None)
 
         # 如果此方向上，该点已经有得分形状，不重复计算
         for shape in score_all_arr:
-            if (x_direction, y_direction) == shape[2] and (m, n) in shape[1]:
+            if shape[0] > 300 and (m, n) in shape[1] and (x_direction, y_direction) == shape[2]:
                 return 0
 
         # 在落子点 左右方向上循环查找得分形状
-        for offset in range(-5, 1):
-            # offset = -2
-            pos = []
-            coord = []
-            for i in range(0, 6):
-                x = m + (i + offset) * x_direction
-                y = n + (i + offset) * y_direction
-                coord.append((x, y))
-                if x >= self.chessboard_size or x < 0 or y >= self.chessboard_size or y < 0:
-                    pos.append(2)
-                elif chessboard[x][y] == 0:
-                    pos.append(0)
-                elif chessboard[x][y] == color:
-                    pos.append(1)
-                else:
-                    pos.append(2)
-            shape_5 = (pos[0], pos[1], pos[2], pos[3], pos[4])
-            shape_6 = (pos[0], pos[1], pos[2], pos[3], pos[4], pos[5])
+        pos = []
+        coord = []
+        for i in range(-5, 6):
+            x = m + i * x_direction
+            y = n + i * y_direction
+            coord.append((x, y))
+            if x >= self.chessboard_size or x < 0 or y >= self.chessboard_size or y < 0:
+                pos.append(2)
+            elif chessboard[x][y] == 0:
+                pos.append(0)
+            elif chessboard[x][y] == color:
+                pos.append(1)
+            else:
+                pos.append(2)
 
+        for j in range(0, 6):
+            shape_5 = (pos[j], pos[j + 1], pos[j + 2], pos[j + 3], pos[j + 4])
+            shape_6 = (pos[j], pos[j + 1], pos[j + 2], pos[j + 3], pos[j + 4], pos[j + 5])
             for (score, shape) in shape_score_6:
-                if shape_6 == shape:
-                    if score > max_score_shape[0]:
-                        max_score_shape = (score, (coord[0], coord[1], coord[2], coord[3], coord[4], coord[5]),
-                                           (x_direction, y_direction))
-            for (score, shape) in shape_score_5:
-                if shape_5 == shape:
-                    if score > max_score_shape[0]:
-                        max_score_shape = (score, (coord[0], coord[1], coord[2], coord[3], coord[4]),
-                                           (x_direction, y_direction))
+                if score > max_score_shape[0] and shape_6 == shape:
+                    max_score_shape = (
+                        score, (coord[j], coord[j + 1], coord[j + 2], coord[j + 3], coord[j + 4], coord[j + 5]),
+                        (x_direction, y_direction))
+            for (score, shape) in shape_score_5:
+                if score > max_score_shape[0] and shape_5 == shape:
+                    max_score_shape = (
+                        score, (coord[j], coord[j + 1], coord[j + 2], coord[j + 3], coord[j + 4]),
+                        (x_direction, y_direction))
+
+        shape_tmp = (pos[6], pos[7], pos[8], pos[9], pos[10])
+        for (score, shape) in shape_score_5:
+            if score > max_score_shape[0] and shape_tmp == shape:
+                max_score_shape = (
+                    score, (coord[6], coord[7], coord[8], coord[9], coord[10]),
+                    (x_direction, y_direction))
 
         add_score = 0  # 加分项
         # 计算两个形状相交， 如两个3活 相交， 得分增加
@@ -319,10 +345,14 @@
                 for pt1 in shape[1]:
                     for pt2 in max_score_shape[1]:
                         if pt1 == pt2:
-                            add_score += (shape[0] + max_score_shape[0]) / 2
+                            if shape[0] >= 1000 and max_score_shape[0] >= 1000:
+                                add_score = (shape[0] + max_score_shape[0]) / 2
+                            else:
+                                add_score = min(shape[0], max_score_shape[0])
                             break
                     else:
-                        break
+                        continue  # 其中else块中的语句将在for循环完整执行过之后才会被执行，如果for循环被break，则else块将不会被执行。
+                    break  # 如果有一个子对上了 就不再给这个棋形重复加分了
             score_all_arr.append(max_score_shape)
 
         return add_score + max_score_shape[0]
